<script>
    // =============================================================================
    // STATE
    // =============================================================================
    
    let state = {
        holdings: [],
        cryptoHoldings: [],
        totalValue: 0,
        stocksValue: 0,
        cryptoValue: 0,
        lastUpdate: null,
        currency: 'GBP',
        exchangeRate: { gbpToUsd: 1.27, usdToGbp: 0.79 },
        charts: { allocation: null, topHoldings: null },
        chatHistory: [],
        currentFilter: 'all',
        apiConfig: { t212: false, coingecko: false, anthropic: false }
    };
    
    // =============================================================================
    // CRYPTO MAPPING
    // =============================================================================
    
    const CRYPTO_MAP = {
        'BTC': 'bitcoin', 'WBTC': 'wrapped-bitcoin', 'BTCB': 'bitcoin',
        'ETH': 'ethereum', 'WETH': 'weth', 'STETH': 'staked-ether',
        'SOL': 'solana', 'BNB': 'binancecoin', 'XRP': 'ripple',
        'ADA': 'cardano', 'DOGE': 'dogecoin', 'DOGE-BEP': 'dogecoin',
        'DOT': 'polkadot', 'DOT-BEP': 'polkadot', 'LINK': 'chainlink',
        'AVAX': 'avalanche-2', 'SHIB': 'shiba-inu', 'LTC': 'litecoin',
        'TRX': 'tron', 'BCH': 'bitcoin-cash', 'FTM': 'fantom',
        'ARB': 'arbitrum', 'INJ': 'injective-protocol', 'SUI': 'sui',
        'USDT': 'tether', 'ZUSDT': 'tether', 'USDT-Linea': 'tether', 'BSC-USD': 'tether',
        'USDC': 'usd-coin', 'USDC.E': 'usd-coin', 'BUSD': 'binance-usd',
        'PEPE': 'pepe', 'BONK': 'bonk', 'FLOKI': 'floki',
        'WIF': 'dogwifhat', 'PONKE': 'ponke', '$MYRO': 'myro',
        'POL': 'matic-network', 'TIA': 'celestia', 'METIS': 'metis-token',
        'FET': 'artificial-superintelligence-alliance',
        'RENDER': 'render-token', 'JUP': 'jupiter-exchange-solana',
        'ORCA': 'orca', 'PAXG': 'pax-gold', 'OMNOM': 'doge-eat-doge',
    };
    
    // Crypto holdings - EDIT THIS SECTION WITH YOUR CRYPTO HOLDINGS
    const CRYPTO_HOLDINGS = [
        { ticker: 'WBTC', name: 'Wrapped Bitcoin', units: 2.09433415, costBasisUsd: 67550.45 },
        { ticker: 'ZUSDT', name: 'Bridged Tether Zilliqa', units: 135106.8131, costBasisUsd: 0.9472 },
        { ticker: 'USDT', name: 'Tether USD', units: 10000, costBasisUsd: 1.00 },
        { ticker: 'BSC-USD', name: 'Binance-Peg BSC-USD', units: 44685.23, costBasisUsd: 1.00 },
        { ticker: 'ETH', name: 'Ethereum', units: 7.1598, costBasisUsd: 2850 },
        { ticker: 'SOL', name: 'Solana', units: 48.08, costBasisUsd: 145 },
        { ticker: 'BNB', name: 'BNB', units: 12.8866, costBasisUsd: 580 },
        { ticker: 'TIA', name: 'Celestia', units: 372.83, costBasisUsd: 8.25 },
        { ticker: 'SUI', name: 'Sui', units: 1250.12, costBasisUsd: 1.85 },
        { ticker: 'METIS', name: 'Metis Token', units: 42.47, costBasisUsd: 68 },
        { ticker: 'INJ', name: 'Injective', units: 70.5, costBasisUsd: 28 },
        { ticker: 'PEPE', name: 'Pepe', units: 150000000, costBasisUsd: 0.0000085 },
        { ticker: 'BONK', name: 'Bonk', units: 15000000, costBasisUsd: 0.000018 },
        { ticker: 'WIF', name: 'dogwifhat', units: 450, costBasisUsd: 2.15 },
        { ticker: 'FLOKI', name: 'FLOKI', units: 2500000, costBasisUsd: 0.00015 },
        { ticker: 'FET', name: 'Artificial Superintelligence Alliance', units: 520, costBasisUsd: 1.85 },
        { ticker: 'RENDER', name: 'Render Token', units: 85, costBasisUsd: 7.50 },
        { ticker: 'JUP', name: 'Jupiter', units: 1200, costBasisUsd: 0.95 },
        { ticker: 'OMNOM', name: 'Doge Eat Doge', units: 2590000000, costBasisUsd: 0.0000536 },
        { ticker: 'PONKE', name: 'Ponke', units: 2500, costBasisUsd: 0.42 },
    ];
    
    // =============================================================================
    // CURRENCY UTILITIES
    // =============================================================================
    
    function setCurrency(currency) {
        state.currency = currency;
        document.getElementById('btnGBP').classList.toggle('active', currency === 'GBP');
        document.getElementById('btnUSD').classList.toggle('active', currency === 'USD');
        updateUI();
    }
    
    function convertToDisplayCurrency(valueGbp) {
        if (state.currency === 'USD') {
            return valueGbp * state.exchangeRate.gbpToUsd;
        }
        return valueGbp;
    }
    
    function formatCurrency(value) {
        if (!value && value !== 0) return state.currency === 'GBP' ? '¬£0' : '$0';
        const symbol = state.currency === 'GBP' ? '¬£' : '$';
        const displayValue = convertToDisplayCurrency(value);
        return symbol + displayValue.toLocaleString('en-GB', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
    }
    
    function formatPrice(price) {
        if (!price) return state.currency === 'GBP' ? '¬£0.00' : '$0.00';
        const symbol = state.currency === 'GBP' ? '¬£' : '$';
        let displayPrice = convertToDisplayCurrency(price);
        
        if (displayPrice < 0.0001) return symbol + displayPrice.toExponential(2);
        if (displayPrice < 0.01) return symbol + displayPrice.toFixed(6);
        if (displayPrice < 1) return symbol + displayPrice.toFixed(4);
        return symbol + displayPrice.toLocaleString('en-GB', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    
    function formatNumber(num) {
        if (!num) return '0';
        if (num >= 1000000000) return (num / 1000000000).toFixed(2) + 'B';
        if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
        if (num >= 1000) return num.toLocaleString('en-GB', { maximumFractionDigits: 2 });
        if (num < 0.0001) return num.toExponential(2);
        return num.toFixed(4);
    }
    
    function formatPnl(pnl, pnlPercent) {
        if (pnl === null || pnl === undefined) return '-';
        const symbol = state.currency === 'GBP' ? '¬£' : '$';
        const displayPnl = convertToDisplayCurrency(pnl);
        const sign = displayPnl >= 0 ? '+' : '';
        return `${sign}${symbol}${Math.abs(displayPnl).toLocaleString('en-GB', { maximumFractionDigits: 0 })} (${sign}${pnlPercent?.toFixed(1) || 0}%)`;
    }
    
    function truncate(str, len) {
        if (!str) return '';
        return str.length > len ? str.substring(0, len) + '...' : str;
    }
    
    // =============================================================================
    // API CALLS (Using server proxy)
    // =============================================================================
    
    async function checkApiConfig() {
        try {
            const response = await fetch('/api/config');
            const config = await response.json();
            state.apiConfig = {
                t212: config.t212Configured,
                coingecko: config.coingeckoConfigured,
                anthropic: config.anthropicConfigured
            };
            
            // Update config status display
            document.getElementById('t212Check').textContent = config.t212Configured ? '‚úÖ' : '‚ùå';
            document.getElementById('t212Check').className = 'config-check ' + (config.t212Configured ? 'ok' : 'fail');
            
            document.getElementById('cgCheck').textContent = config.coingeckoConfigured ? '‚úÖ' : '‚ö†Ô∏è';
            document.getElementById('cgCheck').className = 'config-check ' + (config.coingeckoConfigured ? 'ok' : 'fail');
            
            document.getElementById('aiCheck').textContent = config.anthropicConfigured ? '‚úÖ' : '‚ùå';
            document.getElementById('aiCheck').className = 'config-check ' + (config.anthropicConfigured ? 'ok' : 'fail');
            
            return config;
        } catch (error) {
            console.error('Config check failed:', error);
            return { t212Configured: false, coingeckoConfigured: false, anthropicConfigured: false };
        }
    }
    
    async function fetchExchangeRate() {
        try {
            const response = await fetch('/api/exchange-rate');
            const data = await response.json();
            state.exchangeRate = data;
        } catch (e) {
            console.log('Using default exchange rate');
        }
    }
    
    async function fetchT212Portfolio() {
        updateLoadingText('Fetching Trading 212 portfolio...');
        
        try {
            const response = await fetch('/api/t212/portfolio');
            
            if (!response.ok) {
                throw new Error('T212 API error');
            }
            
            const data = await response.json();
            console.log('‚úÖ T212 Portfolio fetched:', data.length, 'positions');
            return processT212Data(data);
        } catch (error) {
            console.error('T212 fetch error:', error);
            showError('Could not fetch Trading 212 data. Check your API key configuration.');
            return [];
        }
    }
    
    function processT212Data(data) {
        return data.map(position => {
            let priceGbp = position.currentPrice || 0;
            let avgPriceGbp = position.averagePrice || 0;
            
            // Check if price is in GBX (pence)
            const ticker = position.ticker || '';
            const isLikelyGbx = priceGbp > 100 && !ticker.includes('.');
            
            if (isLikelyGbx) {
                priceGbp = priceGbp / 100;
                avgPriceGbp = avgPriceGbp / 100;
            }
            
            const units = position.quantity || 0;
            const currentValue = units * priceGbp;
            const costValue = units * avgPriceGbp;
            const pnl = currentValue - costValue;
            const pnlPercent = costValue > 0 ? ((currentValue - costValue) / costValue) * 100 : 0;
            
            // Determine type
            let type = 'Stock';
            if (/^(VUSA|VWRL|VWRP|VUKE|VUKG|VHYL|VFEG|SPY4|LDEG|XMJP|EIMI|HEAL|IHCU|SMGB|RENG|SGLN|ISPY|DLTM|GGRB|IUKD|UGRW|WNDG|QDVE|NRGT|IITU|TRET|IUSP|FXC|SEMB)/.test(ticker)) {
                type = 'ETF';
            } else if (/^(PCTN|SUPR|SGRO)/.test(ticker)) {
                type = 'REIT';
            }
            
            return {
                ticker: ticker.replace('_EQ', ''),
                name: position.name || ticker,
                type,
                units,
                currentPrice: priceGbp,
                avgPrice: avgPriceGbp,
                currentValue,
                costValue,
                pnl,
                pnlPercent,
                priceSource: 'live',
                isCrypto: false
            };
        }).filter(h => h.units > 0);
    }
    
    async function fetchCryptoPrices() {
        updateLoadingText('Fetching crypto prices...');
        
        // ‚úÖ Edited: only fetch CoinGecko IDs you actually hold (smaller request, fewer failures)
        const heldTickers = [...new Set(CRYPTO_HOLDINGS.map(h => h.ticker))];
        const missing = heldTickers.filter(t => !CRYPTO_MAP[t]);
        if (missing.length) {
            console.warn('Missing CRYPTO_MAP entries for:', missing);
            // Optional UI warning without breaking anything
            showError(`Missing CoinGecko mapping for: ${missing.join(', ')}. Those will use cost-basis estimates.`);
        }
        
        const uniqueCoinIds = [...new Set(heldTickers.map(t => CRYPTO_MAP[t]).filter(Boolean))];
        if (!uniqueCoinIds.length) return {};
        
        try {
            const response = await fetch(`/api/crypto/prices?ids=${uniqueCoinIds.join(',')}`);
            
            if (!response.ok) throw new Error('CoinGecko API error');
            
            const data = await response.json();
            const cryptoPrices = {};
            
            for (const [ticker, coinId] of Object.entries(CRYPTO_MAP)) {
                if (data[coinId]) {
                    cryptoPrices[ticker] = {
                        gbp: data[coinId].gbp || 0,
                        usd: data[coinId].usd || 0,
                        change24h: data[coinId].gbp_24h_change || 0
                    };
                }
            }
            
            console.log('‚úÖ Fetched crypto prices:', Object.keys(cryptoPrices).length);
            return cryptoPrices;
        } catch (error) {
            console.error('Crypto price fetch error:', error);
            return {};
        }
    }
    
    function processCryptoHoldings(cryptoPrices) {
        return CRYPTO_HOLDINGS.map(holding => {
            const price = cryptoPrices[holding.ticker];
            const currentPriceGbp = price?.gbp || (holding.costBasisUsd * state.exchangeRate.usdToGbp);
            const costPriceGbp = holding.costBasisUsd * state.exchangeRate.usdToGbp;
            
            const currentValue = holding.units * currentPriceGbp;
            const costValue = holding.units * costPriceGbp;
            const pnl = currentValue - costValue;
            const pnlPercent = costValue > 0 ? ((currentValue - costValue) / costValue) * 100 : 0;
            
            return {
                ticker: holding.ticker,
                name: holding.name,
                type: 'Crypto',
                units: holding.units,
                currentPrice: currentPriceGbp,
                avgPrice: costPriceGbp,
                currentValue,
                costValue,
                pnl,
                pnlPercent,
                // ‚úÖ Edited: use "cached" (matches CSS + table logic)
                priceSource: price ? 'live' : 'cached',
                isCrypto: true
            };
        }).filter(h => h.units > 0 && h.currentValue > 0);
    }
    
    // =============================================================================
    // PORTFOLIO CALCULATIONS
    // =============================================================================
    
    function calculatePortfolio() {
        const allHoldings = [...state.holdings, ...state.cryptoHoldings];
        allHoldings.sort((a, b) => b.currentValue - a.currentValue);
        
        let totalValue = 0;
        let stocksValue = 0;
        let cryptoValue = 0;
        
        allHoldings.forEach(h => {
            totalValue += h.currentValue;
            if (h.isCrypto || h.type === 'Crypto') {
                cryptoValue += h.currentValue;
            } else {
                stocksValue += h.currentValue;
            }
        });
        
        allHoldings.forEach(h => {
            h.weight = totalValue > 0 ? (h.currentValue / totalValue) * 100 : 0;
        });
        
        state.holdings = allHoldings.filter(h => !h.isCrypto);
        state.cryptoHoldings = allHoldings.filter(h => h.isCrypto);
        state.totalValue = totalValue;
        state.stocksValue = stocksValue;
        state.cryptoValue = cryptoValue;
        state.lastUpdate = new Date();
        
        return allHoldings;
    }
    
    // =============================================================================
    // UI UPDATES
    // =============================================================================
    
    function updateUI() {
        const allHoldings = [...state.holdings, ...state.cryptoHoldings].sort((a, b) => b.currentValue - a.currentValue);
        
        const total = state.totalValue;
        allHoldings.forEach(h => {
            h.weight = total > 0 ? (h.currentValue / total) * 100 : 0;
        });
        
        document.getElementById('totalValue').textContent = formatCurrency(state.totalValue);
        document.getElementById('stocksValue').textContent = formatCurrency(state.stocksValue);
        document.getElementById('cryptoValue').textContent = formatCurrency(state.cryptoValue);
        document.getElementById('holdingsCount').textContent = allHoldings.length;
        document.getElementById('lastUpdated').textContent = state.lastUpdate 
            ? state.lastUpdate.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' })
            : '--:--';
        
        updateHoldingsTable(allHoldings);
        updateCharts(allHoldings);
    }
    
    function updateHoldingsTable(allHoldings) {
        const tbody = document.getElementById('holdingsBody');
        let filtered = allHoldings;
        
        if (state.currentFilter !== 'all') {
            filtered = allHoldings.filter(h => h.type === state.currentFilter);
        }
        
        tbody.innerHTML = filtered.map(h => {
            const typeClass = h.type.toLowerCase();
            const iconInitial = h.ticker.substring(0, 2);
            const priceSourceClass = h.priceSource === 'live' ? 'live' : 'cached';
            const priceSourceLabel = h.priceSource === 'live' ? 'LIVE' : 'EST';
            const pnlClass = h.pnl >= 0 ? 'pnl-positive' : 'pnl-negative';
            
            return `
                <tr>
                    <td>
                        <div class="asset-cell">
                            <div class="asset-icon ${typeClass}">${iconInitial}</div>
                            <div class="asset-info">
                                <div class="asset-ticker">${h.ticker}</div>
                                <div class="asset-name">${truncate(h.name, 20)}</div>
                            </div>
                        </div>
                    </td>
                    <td><span class="type-badge ${typeClass}">${h.type}</span></td>
                    <td class="value-cell">${formatNumber(h.units)}</td>
                    <td class="value-cell">
                        ${formatPrice(h.currentPrice)}
                        <span class="price-source ${priceSourceClass}">${priceSourceLabel}</span>
                    </td>
                    <td class="value-cell" style="font-weight: 600;">${formatCurrency(h.currentValue)}</td>
                    <td class="value-cell ${pnlClass}">${formatPnl(h.pnl, h.pnlPercent)}</td>
                    <td>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div class="weight-bar-container">
                                <div class="weight-bar" style="width: ${Math.min(h.weight * 2, 100)}%;"></div>
                            </div>
                            <span style="font-size: 0.8rem; color: var(--text-secondary);">${h.weight.toFixed(1)}%</span>
                        </div>
                    </td>
                </tr>
            `;
        }).join('');
    }
    
    function filterHoldings(type) {
        state.currentFilter = type;
        document.querySelectorAll('.filter-tab').forEach(tab => {
            const tabType = tab.textContent.trim();
            const isActive = (type === 'all' && tabType === 'All') || 
                                (type === 'Crypto' && tabType === 'Crypto') ||
                                (type === 'Stock' && tabType === 'Stocks') ||
                                (type === 'ETF' && tabType === 'ETFs') ||
                                (type === 'REIT' && tabType === 'REITs');
            tab.classList.toggle('active', isActive);
        });
        updateUI();
    }
    
    function updateCharts(allHoldings) {
        updateAllocationChart(allHoldings);
        updateTopHoldingsChart(allHoldings);
    }
    
    function updateAllocationChart(allHoldings) {
        const ctx = document.getElementById('allocationChart').getContext('2d');
        
        const typeValues = {};
        allHoldings.forEach(h => {
            typeValues[h.type] = (typeValues[h.type] || 0) + h.currentValue;
        });
        
        const labels = Object.keys(typeValues);
        const data = Object.values(typeValues).map(v => convertToDisplayCurrency(v));
        const colors = ['#f59e0b', '#6366f1', '#10b981', '#ec4899', '#8b5cf6', '#ef4444'];
        
        if (state.charts.allocation) state.charts.allocation.destroy();
        
        state.charts.allocation = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels,
                datasets: [{
                    data,
                    backgroundColor: colors.slice(0, labels.length),
                    borderWidth: 0,
                    hoverOffset: 8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                cutout: '65%',
                plugins: {
                    legend: {
                        position: 'right',
                        labels: {
                            color: '#94a3b8',
                            font: { family: 'DM Sans', size: 12 },
                            padding: 16,
                            usePointStyle: true
                        }
                    }
                }
            }
        });
    }
    
    function updateTopHoldingsChart(allHoldings) {
        const ctx = document.getElementById('topHoldingsChart').getContext('2d');
        
        const top10 = allHoldings.slice(0, 10);
        const labels = top10.map(h => h.ticker);
        const data = top10.map(h => convertToDisplayCurrency(h.currentValue));
        const symbol = state.currency === 'GBP' ? '¬£' : '$';
        
        if (state.charts.topHoldings) state.charts.topHoldings.destroy();
        
        state.charts.topHoldings = new Chart(ctx, {
            type: 'bar',
            data: {
                labels,
                datasets: [{
                    data,
                    backgroundColor: 'rgba(0, 212, 170, 0.6)',
                    borderColor: '#00d4aa',
                    borderWidth: 1,
                    borderRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y',
                plugins: { legend: { display: false } },
                scales: {
                    x: {
                        ticks: {
                            color: '#64748b',
                            font: { family: 'JetBrains Mono', size: 10 },
                            callback: v => symbol + (v / 1000).toFixed(0) + 'k'
                        },
                        grid: { color: 'rgba(255,255,255,0.05)' }
                    },
                    y: {
                        ticks: { color: '#94a3b8', font: { family: 'JetBrains Mono', size: 11 } },
                        grid: { display: false }
                    }
                }
            }
        });
    }
    
    // =============================================================================
    // STATUS & LOADING
    // =============================================================================
    
    function updateStatus(text, type) {
        const indicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        
        statusText.textContent = text;
        
        if (type === 'success') {
            indicator.style.background = 'rgba(16, 185, 129, 0.15)';
            indicator.style.color = '#10b981';
        } else if (type === 'error') {
            indicator.style.background = 'rgba(239, 68, 68, 0.15)';
            indicator.style.color = '#ef4444';
        } else {
            indicator.style.background = 'rgba(245, 158, 11, 0.15)';
            indicator.style.color = '#f59e0b';
        }
    }
    
    function updateLoadingText(text) {
        document.getElementById('loadingText').textContent = text;
    }
    
    function hideLoading() {
        document.getElementById('loadingOverlay').classList.add('hidden');
    }
    
    function showError(message) {
        const banner = document.getElementById('errorBanner');
        banner.textContent = message;
        banner.classList.add('show');
        setTimeout(() => banner.classList.remove('show'), 10000);
    }
    
    // =============================================================================
    // AI ADVISOR
    // =============================================================================
    
    async function sendMessage() {
        const input = document.getElementById('chatInput');
        const message = input.value.trim();
        if (!message) return;
        
        addMessage(message, 'user');
        input.value = '';
        showTypingIndicator();
        
        try {
            const response = await callClaudeAPI(message);
            removeTypingIndicator();
            addMessage(response, 'assistant');
        } catch (error) {
            removeTypingIndicator();
            addMessage('AI Advisor not available. Make sure ANTHROPIC_API_KEY is configured in your environment variables.', 'system');
        }
    }
    
    function askAdvisor(question) {
        document.getElementById('chatInput').value = question;
        sendMessage();
    }
    
    function buildPortfolioContext() {
        const allHoldings = [...state.holdings, ...state.cryptoHoldings].sort((a, b) => b.currentValue - a.currentValue);
        const top15 = allHoldings.slice(0, 15);
        
        const typeBreakdown = {};
        allHoldings.forEach(h => {
            typeBreakdown[h.type] = (typeBreakdown[h.type] || 0) + h.currentValue;
        });
        
        const totalPnl = allHoldings.reduce((sum, h) => sum + (h.pnl || 0), 0);
        const totalCost = allHoldings.reduce((sum, h) => sum + (h.costValue || 0), 0);
        const totalPnlPercent = totalCost > 0 ? (totalPnl / totalCost) * 100 : 0;
        
        return `
Portfolio Summary (values in GBP):
- Total Value: ¬£${state.totalValue.toLocaleString()}
- Stocks/ETFs/REITs: ¬£${state.stocksValue.toLocaleString()} (${((state.stocksValue/state.totalValue)*100).toFixed(1)}%)
- Cryptocurrency: ¬£${state.cryptoValue.toLocaleString()} (${((state.cryptoValue/state.totalValue)*100).toFixed(1)}%)
- Total Holdings: ${allHoldings.length}
- Overall P&L: ¬£${totalPnl.toLocaleString()} (${totalPnlPercent.toFixed(1)}%)

Asset Type Breakdown:
${Object.entries(typeBreakdown).map(([type, value]) => 
    `- ${type}: ¬£${value.toLocaleString()} (${((value/state.totalValue)*100).toFixed(1)}%)`
).join('\n')}

Top 15 Holdings:
${top15.map((h, i) => 
    `${i+1}. ${h.ticker} (${h.type}): ¬£${h.currentValue.toLocaleString()} - ${h.weight.toFixed(1)}%, P&L: ${h.pnl >= 0 ? '+' : ''}¬£${h.pnl?.toLocaleString() || 0}`
).join('\n')}
        `.trim();
    }
    
    async function callClaudeAPI(userMessage) {
        const systemPrompt = `You are a friendly, conversational financial advisor helping someone understand their investment portfolio. 

GUIDELINES:
- Write naturally, like talking to a friend who's good with money
- Avoid bullet points - use flowing prose
- Be specific with numbers but explain what they mean simply
- Keep responses to 2-3 short paragraphs unless asked for detail
- You're NOT a licensed financial advisor - mention this only if giving buy/sell advice

Current Portfolio Data:
${buildPortfolioContext()}`;

        state.chatHistory.push({ role: 'user', content: userMessage });
        
        const response = await fetch('/api/ai/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                messages: state.chatHistory.slice(-10),
                system: systemPrompt
            })
        });
        
        if (!response.ok) throw new Error('API error');
        
        const data = await response.json();
        const assistantMessage = data.content[0].text;
        state.chatHistory.push({ role: 'assistant', content: assistantMessage });
        
        return assistantMessage;
    }
    
    function addMessage(content, type) {
        const container = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        messageDiv.textContent = content;
        container.appendChild(messageDiv);
        container.scrollTop = container.scrollHeight;
    }
    
    function showTypingIndicator() {
        const container = document.getElementById('chatMessages');
        const typingDiv = document.createElement('div');
        typingDiv.className = 'message assistant';
        typingDiv.id = 'typingIndicator';
        typingDiv.innerHTML = `<div class="typing-indicator"><div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div></div>`;
        container.appendChild(typingDiv);
        container.scrollTop = container.scrollHeight;
    }
    
    function removeTypingIndicator() {
        const indicator = document.getElementById('typingIndicator');
        if (indicator) indicator.remove();
    }
    
    function handleKeyPress(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            sendMessage();
        }
    }
    
    // =============================================================================
    // REFRESH
    // =============================================================================
    
    async function refreshAll() {
        updateStatus('Refreshing...', 'pending');
        
        try {
            await fetchExchangeRate();
            
            const t212Holdings = await fetchT212Portfolio();
            state.holdings = t212Holdings;
            
            const cryptoPrices = await fetchCryptoPrices();
            state.cryptoHoldings = processCryptoHoldings(cryptoPrices);
            
            calculatePortfolio();
            updateUI();
            
            updateStatus('Live', 'success');
        } catch (error) {
            console.error('Refresh error:', error);
            updateStatus('Error', 'error');
        }
    }
    
    // =============================================================================
    // INIT
    // =============================================================================
    
    async function init() {
        console.log('üöÄ Portfolio Command Center initializing...');
        
        try {
            // Check API configuration
            updateLoadingText('Checking API configuration...');
            await checkApiConfig();
            
            // Fetch exchange rate
            updateLoadingText('Fetching exchange rates...');
            await fetchExchangeRate();
            
            // Fetch T212 portfolio
            const t212Holdings = await fetchT212Portfolio();
            state.holdings = t212Holdings;
            
            // Fetch crypto prices
            const cryptoPrices = await fetchCryptoPrices();
            state.cryptoHoldings = processCryptoHoldings(cryptoPrices);
            
            // Calculate portfolio
            updateLoadingText('Calculating portfolio...');
            calculatePortfolio();
            
            // Update UI
            updateUI();
            
            hideLoading();
            
            if (state.holdings.length > 0 || state.cryptoHoldings.length > 0) {
                updateStatus('Live', 'success');
            } else {
                updateStatus('No Data', 'warning');
                document.getElementById('configStatus').style.display = 'block';
            }
            
            console.log('‚úÖ Initialization complete');
            console.log(`üìä Total Portfolio: ${formatCurrency(state.totalValue)}`);
            
            // Auto-refresh every 60 seconds
            setInterval(refreshAll, 60000);
            
        } catch (error) {
            console.error('‚ùå Initialization error:', error);
            hideLoading();
            updateStatus('Error', 'error');
            document.getElementById('configStatus').style.display = 'block';
        }
    }
    
    window.addEventListener('load', init);
</script>
